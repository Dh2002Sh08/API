const express = require('express');
const { Worker } = require('worker_threads');
const { generateSigner } = require('@metaplex-foundation/umi');
const { createUmi } = require('@metaplex-foundation/umi-bundle-defaults');
const os = require('os');

const app = express();
const port = process.env.PORT || 3001; // Render sets PORT, fallback to 3001 locally

app.get('/mint', async (req, res) => {
    const { prefix, endpoint = 'https://api.devnet.solana.com', numWorkers = os.cpus().length } = req.query;

    if (!prefix) {
        return res.status(400).json({ error: 'Prefix is required' });
    }

    try {
        const mint = await generateVanityMintSigner(prefix, endpoint, parseInt(numWorkers));
        console.log("Generated Mint Public Key:", mint.publicKey.toString());

        // Return the full mint object in a JSON-serializable format
        res.status(200).json({
            publicKey: mint.publicKey.toString(),
            secretKey: Array.from(mint.secretKey) // Convert Uint8Array to array
        });
    } catch (error) {
        console.error('API Error:', error);
        res.status(500).json({ error: error.message });
    }
});

async function generateVanityMintSigner(targetPrefix, endpoint, numWorkers) {
    return new Promise((resolve, reject) => {
        let found = false;
        const workers = [];
        const startTime = Date.now();

        console.log(`Starting parallel search for vanity token mint with prefix "${targetPrefix}" using ${numWorkers} workers...`);

        const workerScript = `
            const { parentPort } = require('worker_threads');
            const { generateSigner } = require('@metaplex-foundation/umi');
            const { createUmi } = require('@metaplex-foundation/umi-bundle-defaults');

            const umi = createUmi('${endpoint}');
            const targetPrefix = '${targetPrefix}';

            let attempts = 0;
            while (true) {
                const mint = generateSigner(umi);
                const mintAddress = mint.publicKey.toString();
                attempts++;
                if (mintAddress.startsWith(targetPrefix)) {
                    parentPort.postMessage({
                        publicKey: mint.publicKey.toString(),
                        secretKey: Array.from(mint.secretKey),
                        attempts: attempts
                    });
                    break;
                }
            }
        `;

        for (let i = 0; i < numWorkers; i++) {
            const worker = new Worker(workerScript, { eval: true });
            workers.push(worker);

            worker.on('message', (mintData) => {
                if (!found) {
                    found = true;
                    const mint = {
                        publicKey: mintData.publicKey,
                        secretKey: Uint8Array.from(mintData.secretKey)
                    };

                    const duration = (Date.now() - startTime) / 1000;
                    console.log(`\nVanity Token Mint Generated by Worker ${i}!`);
                    console.log("Mint Address:", mint.publicKey);
                    console.log(`Attempts by this worker: ${mintData.attempts}`);
                    console.log(`Search completed in ${duration.toFixed(2)} seconds`);

                    resolve(mint);
                    workers.forEach(w => w.terminate());
                }
            });

            worker.on('error', (err) => {
                if (!found) {
                    console.error(`Worker ${i} error:`, err);
                    reject(new Error(`Worker ${i} error: ${err.message}`));
                }
            });

            worker.on('exit', (code) => {
                if (code !== 0 && !found) {
                    console.error(`Worker ${i} exited with code ${code}`);
                }
            });
        }

        let totalAttempts = 0;
        const progressInterval = setInterval(() => {
            if (!found) {
                totalAttempts += numWorkers * 1000;
                console.log(`Still searching... ~${totalAttempts} attempts across ${numWorkers} workers`);
            } else {
                clearInterval(progressInterval);
            }
        }, 5000);
    });
}

app.listen(port, () => {
    console.log(`Server running on port ${port}`);
});